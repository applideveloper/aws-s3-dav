var AWS = require('aws-sdk');
var DAV = {};
var doc = document;

// Hack for node-webkit runtime on node
AWS.util.isBrowser = function() {
    return false;
};
DAV.Server = new AWS.S3();

(function(DAV) {

    DAV.Setting = ({
        trigger:       doc.querySelector('.config'),
        form:          doc.getElementById('setting'),
        saveButton:    doc.querySelector('#setting button'),
        opened:        false,
        savedCallback: null,

        init: function() {
            this.trigger.addEventListener('click', this, false);
            this.saveButton.addEventListener('click', this);

            return this;
        },
        
        handleEvent: function(evt) {
            var target = evt.target;

            if ( target === this.trigger ) {
                if ( this.opened === false ) {
                    this.show();
                } else {
                    this.hide();
                }
                this.opened = !this.opened;
            } else if ( target.webkitMatchesSelector('#setting button') ) {
                evt.preventDefault();
                this.save();
            }
        },

        show: function(savedCallback, lock) {
            DAV.Layer.show(false);
            DAV.Layer.addRelationElement(this.form);
            if ( lock ) {
                DAV.layer.lock();
            }
            this.form.style.display = 'block';
            this.setErrorMessage('');
            this.setButtonState();

            this.savedCallback = savedCallback || null;
        },

        hide: function() {
            Layer.hide();
            this.form.style.display = 'none';
        },

        getConfigObject: function() {
            var keyId  = localStorage.getItem('accessKeyId'),
                secret = localStorage.getItem('secretAccessKey');

            if ( keyId && secret ) {
                this.form.querySelector('#inputAccessKey').value       = keyId;
                this.form.querySelector('#inputSecretAccessKey').value = secret;
                return {
                    accessKeyId:     keyId,
                    secretAccessKey: secret
                };
            } else {
                return null;
            }
        },

        setErrorMessage: function(msg) {
            this.form.querySelector('#settingError').textContent = msg;
        },

        setButtonState: function(status) {
            var button = this.saveButton;

            button.classList.remove('btn-danger');
            button.classList.remove('btn-success');
            button.classList.remove('btn-primary');
            
            switch ( status ) {
                case 'saved':
                    button.classList.add('btn-success');
                    button.textContent = 'saved!';
                    break;

                case 'error':
                    button.classList.add('btn-danger');
                    break;

                default:
                    button.classList.add('btn-primary');
                    button.textContent = 'save';
                    break;
            }
        },

        save: function() {
            var keyId  = this.form.querySelector('#inputAccessKey').value,
                secret = this.form.querySelector('#inputSecretAccessKey').value,
                that   = this;

            if ( keyId === '' || secret === '' ) {
                this.setErrorMessage('Both value must not be empty.');
                this.setButtonState('error');
                return;
            }

            localStorage.setItem('accessKeyId', keyId);
            localStorage.setItem('secretAccessKey', secret);
            DAV.Server.config.update({
                accessKeyId:     keyId,
                secretAccessKey: secret
            });

            this.setErrorMessage('');
            this.setButtonState('saved');

            // A few times delay
            setTimeout(function() {
                DAV.Layer.hide();
                that.hide();
                if ( typeof that.savedCallback === 'function' ) {
                    that.savedCallback();
                    that.savedCallback = null;
                }
            }, 1000);
        }
    }).init();

})(DAV);

(function(DAV) {

    DAV.SideMenu = ({
        menu: doc.querySelector('.buckets > .nav'),

        init: function() {
            this.menu.addEventListener('click', this, false);
            return this;
        },

        handleEvent: function(evt) {
            var item       = evt.target.parentNode,
                bucketName = item.getAttribute('data-bucketname');

            evt.preventDefault();

            this.setActiveElement(item);
            DAV.currentBucket = bucketName;
            DAV.Breadcrumb.reset();
            DAV.loadObjects(bucketName, '/');
        },

        append: function(item, active) {
            this.menu.appendChild(item);

            if ( active ) {
                this.setActiveElement(item);
            }
        },

        setActiveElement: function(item) {
            if ( this.activeMenu ) {
                this.activeMenu.classList.remove('active');
            }
            item.classList.add('active');
            this.activeMenu = item;
            localStorage.setItem('selectedBucket', item.getAttribute('data-bucketname'));
        }
    }).init();

})(DAV);

(function(DAV) {

    DAV.Breadcrumb = ({
        node:   doc.querySelector('.breadcrumb'),
        items:  null,
        active: null,

        init: function() {
            this.items = this.node.getElementsByTagName('a');

            return this;
        },

        getCurrentDirectory: function() {
            var paths = [];

            [].forEach.call(this.items, function(item) {
                var dir = item.parentNode.getAttribute('data-directoryname');

                if ( dir !== '/' ) {
                    paths.push(dir);
                }
            });

            return ( paths.length > 0 ) ? paths.join('/') + '/' : '';
        },

        append: function(pathName) {
            var li = doc.createElement('li'),
                a  = doc.createElement('a');

            if ( this.active ) {
                this.active.classList.remove('active');
            }

            li.classList.add('active');
            li.setAttribute('data-directoryname', pathName);
            a.setAttribute('href', 'javascript:void(0)');
            a.appendChild(doc.createTextNode(pathName));

            li.appendChild(a);
            this.node.appendChild(li);
        },

        reset: function() {
            while ( this.node.firstChild ) {
                this.node.removeChild(this.node.firstChild);
            }
        },

        remove: function(pathName) {
            var finded = false,
                node   = this.node;

            [].forEach.call(this.items, function(item) {
                if ( finded === true || item.getAttribute('href').slice(1) === pathName ) {
                    finded = true;
                    node.removeChild(item.parentNode);
                }
            });

            if ( this.items.length > 0 ) {
                this.items[this.items.length - 1].parentNode.classList.add('active');
            }
        }
    }).init();

})(DAV);

(function(DAV) {

    DAV.Layer = ({
        layer       : doc.getElementById('layer'),
        notification: layer.querySelector('p'),
        relations   : [],
        locked      : false,

        init: function() {
            this.layer.addEventListener('click', this, false);

            return this;
        },

        get: function() {
            return this.layer;
        },

        handleEvent: function(evt) {
            if ( this.locked === false ) {
                this.hide();
            }
        },

        lock: function() {
            this.locked = true;
        },

        unlock: function() {
            this.locked = false;        
        },

        show: function(isLoading, msg) {
            this.layer.style.display = 'block';
            if ( msg ) {
                this.notification.textContent = msg;
            }
            if ( !!isLoading ) {
                this.layer.classList.add('loading');
            }
        },

        addRelationElement: function() {
            this.relations = [].slice.call(arguments);
        },

        hide: function() {
            this.layer.style.display = 'none';
            this.layer.classList.remove('loading');
            this.notification.textContent = '';

            if ( this.relations.length > 0 ) {
                this.relations.forEach(function(node) {
                    node.style.display = 'none';
                });
                this.relations.length = 0;
            }
            this.unlock();
        },

        notify: function(msg) {
            this.notification.textContent = msg;
        }
    }).init();
})(DAV);

(function(DAV) {

    DAV.Bucket = Bucket;

    var bucketCache = [];
    var when        = require('when');
    var fs          = require('fs');
    var Path        = require('path');

    /**
     * Constructor
     * @param AWS.S3 instance
     */
    function Bucket(bucketObject) {
        this._bucket  = bucketObject;
        this._objects = null;
    }

    /**
     * Get Bucket list
     * @access static
     * @return deferred
     */
    Bucket.getBucketList = function() {
        var deferred = when.defer(),
            buckets  = [];

        if ( bucketCache.length > 0 ) {
            deferred.resolve(bucketCahce);
        } else {
            DAV.Server.listBuckets({}, function(err, data) {
                if ( err ) {
                    deferred.reject(err);
                } else {
                    data.Buckets.forEach(function(bucket) {
                        buckets.push(new DAV.Bucket(bucket));
                    });
                    bucketCache = buckets;
                    deferred.resolve(bucketCache);
                }
            });
        }

        return deferred.promise;
    };

    /**
     * Get bucket name
     * @return string
     */
    Bucket.prototype.getName = function() {
        return this._bucket.Name || "";
    };

    /**
     * Get Objects in this bucket
     * @param String dir
     * @return Array<Item>
     */
    Bucket.prototype.getItems = function(dir) {
        var deferred = when.defer(),
            that     = this,
            name     = this.getName(),
            contents = [],
            marker   = (dir || '/').replace(/^\//, '');

        if ( this._objects ) {
            deferred.resolve(this._objects);
        } else {
            DAV.Server.listObjects({"Bucket": name, "Marker": marker}, function(err, data) {
                if ( err ) {
                    deferred.reject(err);
                } else {
                    console.log(data);
                    that._objects = new DAV.ItemList(data.Contents);
                    deferred.resolve(that._objects);
                }
            });
        }

        return deferred.promise;
    };

    Bucket.uploadObject = function(files) {
        var i = 0;

        DAV.Layer.show(true, 'アップロードを開始します');
        DAV.Layer.lock();

        (function upload(file) {
            console.log(file);
            if ( file === void 0) {
                DAV.Layer.hide();
                alert('Upload completed!');
                return;
            }

            DAV.Layer.notify(Path.basename(file.name) + 'をアップロード中…');

            fs.readFile(file.path, function(err, buffer) {
                if ( err ) {
                    return;
                }
                var params = {
                    Key: DAV.Breadcrumb.getCurrentDirectory() + Path.basename(file.name),
                    Body: buffer,
                    Bucket: DAV.currentBucket
                };

                console.log(params);

                DAV.Server.putObject(params, function(err) {
                    if ( err ) {
                        return alert('Error: upload failed "' + file.name);
                    }
                    upload(files[i++]);
                });
            });
        })(files[i++]);
    };

})(DAV);

(function(DAV) {

    DAV.ItemList = ItemList;

    /**
     * Constructor
     */
    function ItemList(listObjects) {
        this.items = listObjects.map(function(item) {
            return new DAV.Item(item);
        });
    }

    ItemList.prototype.getFilteredItems = function() {
        var currentDir = DAV.Breadcrumb.getCurrentDirectory(),
            that       = this;

        return this.items.filter(function(item) {
            return that.compareDirectoryPath(item.getName(), currentDir);
        });       
    };

    ItemList.prototype.compareDirectoryPath = function(name, currentDir) {
        console.log(arguments);
        var path;

        if ( currentDir !== '' && name.indexOf(currentDir) !== 0 ) {
            return false;
        }

        path = name.replace(currentDir, '').replace(/\/$/, '');
        return name !== currentDir && path.indexOf('/') === -1;

    };

    ItemList.prototype.getItems = function() {
        return this.getFilteredItems();
    };

    ItemList.prototype.getItemElements = function() {
        var list = [];

        this.getFilteredItems().forEach(function(item) {
            list.push(item.getElement());
        });

        return list;
    };
})(DAV);

(function(DAV) {

    var Path = require('path');
    var when = require('when');
    var StringDecoder = require('string_decoder');

    DAV.Item = Item;

    /**
     * Constructor
     */
    function Item(obj) {
        this.obj      = obj;
        this.element  = null;
        this.itemType = this._detectItemType(obj.Key);
    }

    Item.prototype.getName = function() {
        return this.obj.Key;
    };

    Item.prototype.getElement = function() {
        var txt;

        if ( ! this.element ) {
            this.element = doc.createElement('div');
            this.element.classList.add('icon-' + this.itemType);
            txt = doc.createElement('p');
            if ( this.itemType == 'directory' ) {
                txt.appendChild(doc.createTextNode(this.obj.Key.replace(/\/$/, '')));
            } else {
                txt.appendChild(doc.createTextNode(this.obj.Key.split('/').pop()));
            }
            this.element.appendChild(txt);
        }

        return this.element;
    };

    Item.prototype._detectItemType = function(name) {
        var types = {
            'directory': /.+\/$/,
            'image': /.+\.(gif|jpe?g|png)$/,
            'file': /.*/
        }, type;

        Object.keys(types).forEach(function(key) {
            if ( ! type && types[key].test(name) ) {
                type = key;
            }
        });

        return type;
    };

    Item.prototype.getObject = function(bucketName) {
        var deferred = when.defer();
        var file     = this.obj;

        DAV.Server.getObject({Bucket: bucketName, Key: file.Key}, function(err, data) {
            if ( err ) {
                deferred.reject(err);
                return;
            }

            // trick: convert node's Buffer to JavaScript ArrayBuffer
            var size      = data.Body.length,
                aryBuffer = new ArrayBuffer(size),
                uint8     = new Uint8Array(aryBuffer),
                i         = 0,
                dataView, // JS DataView
                blob,     // JS Blob
                url;      // Object URL

            for ( ; i < size; ++i ) {
                uint8[i] = data.Body[i];
            }

            dataView = new DataView(aryBuffer);
            blob     = new Blob([dataView], {type: 'application/octet-stream'});
            url      = window.webkitURL.createObjectURL(blob);

            // resolve these data
            deferred.resolve({
                 size: data.ContentLength,
                 name: file.Key.split('/').pop(),
                 downloadURL: url,
                 buffer: data.Body
            });
        });

        return deferred.promise;
    };
})(DAV);

(function(DAV) {

    DAV.fileListCache = {};

    DAV.FileList = ({
        element: doc.getElementById('bucketObjects'),

        init: function() {
            return this;
        },

        getByCache: function(key, dir) {
            if ( key in DAV.fileListCache ) {
                return ( dir in DAV.fileListCache[key] ) ? DAV.fileListCache[key][dir] : null;
            }
            return null;
        },

        purgeCache: function(key, dir) {
            if ( key in DAV.fileListCache ) {
                if ( dir ) {
                    if ( dir in DAV.fileListCache[key] ) {
                        delete DAV.fileListCache[key][dir];
                    }
                } else {
                    delete DAV.fileListCache[key];
                }
            }
        },

        reload: function(list, dir) {
            var element = this.element,
                cache   = [];

            while ( element.firstChild ) {
                element.removeChild(element.firstChild);
            }

            list.forEach(function(item) {
                var instance;

                element.appendChild(item.getElement());
                if ( ! (item instanceof FileItem) ) {
                    cache.push(new FileItem(item));
                } else  {
                    cache.push(item);
                }
            });

            if ( ! (DAV.fileListCache[DAV.currentBucket]) ) {
                DAV.fileListCache[DAV.currentBucket] = {};
            }
            DAV.fileListCache[DAV.currentBucket][dir] = cache;
        }
    }).init();


    function FileItem(node) {
        this.obj      = node.obj;
        this.element  = node.element;
        this.itemType = node.itemType;
        this.item     = node;
        
        DAV.Item.prototype.getElement.call(this);
        this.initialize();
    }

    FileItem.prototype.getElement = function() {
        return this.element;
    };
    FileItem.prototype.getName = function() {
        return DAV.Item.prototype.getName.call(this);
    };
    FileItem.prototype.initialize = function() {
        this.element.addEventListener('click', this);
    };
    FileItem.prototype.handleEvent = function(evt) {
        var dir;

        switch ( this.itemType ) {
            case 'directory':
                dir = this.getName();
                DAV.Breadcrumb.append(dir.replace(/\/$/, ''));
                DAV.loadObjects(DAV.currentBucket, dir);
                break;

            default:
                this.item.getObject(DAV.currentBucket)
                .done(function(data) {
                    DAV.FileDetail.show(data);
                });
                break;
        }
    };

})(DAV);

(function(DAV) {

    var fs   = require('fs');

    DAV.FileDetail = ({
        node: doc.getElementById('fileDetail'),
        dialog: doc.getElementById('downloadFile'),
        fileData: null,

        init: function() {
            this.node.addEventListener('click', this, false);
            this.dialog.addEventListener('change', this, false);
            doc.addEventListener('click', this, false);

            return this;
        },

        handleEvent: function(evt) {
            evt.stopPropagation();

            if ( evt.target.webkitMatchesSelector('button.btn-success') ) {
                this.openDialog();
            } else if ( evt.type === 'change' && evt.target === this.dialog ) {
                this.downloadFile(evt.target.value);
            } else {
                this.hide();
            }
        },

        show: function(fileData) {
            this.fileData = new FileData(fileData);

            // Remove child nodes
            while ( this.node.firstChild ) {
                this.node.removeChild(this.node.firstChild);
            }

            this.node.appendChild(this.fileData.getElement());
            this.node.classList.add('active');
        },

        hide: function() {
            this.node.classList.remove('active');
            this.dialog.value = '';
        },

        openDialog: function() {
            var evt = doc.createEvent('MouseEvent');

            evt.initEvent('click', true, false);
            this.dialog.setAttribute('nwsaveas', this.fileData.getFileName());
            this.dialog.dispatchEvent(evt);
        },

        downloadFile: function(savePath) {
            if ( ! this.fileData ) {
                return;
            }
            var that = this;

            DAV.Layer.show(true, this.fileData.getFileName() + 'をダウンロード中…');
            DAV.Layer.lock();

            fs.writeFile(savePath, this.fileData.getFileBuffer(), function(err) {
                if ( err ) {
                    alert('File save failed.');
                }
                DAV.Layer.hide();
            });

        }
    }).init();


    function FileData(fd) {
        this.fd = fd;
    }

    FileData.prototype.getElement = function() {
        var fragment = doc.createDocumentFragment(),
            fileName = doc.createElement('p'),
            fileSize = doc.createElement('p'),
            download = doc.createElement('button');

        fileName.appendChild(doc.createTextNode('FileName: ' + this.getFileName()));
        fileSize.appendChild(doc.createTextNode('FileSize: ' + this.getFileSize()));
        download.setAttribute('class', 'btn btn-success');
        download.appendChild(doc.createTextNode('Download'));

        fragment.appendChild(fileName);
        fragment.appendChild(fileSize);
        fragment.appendChild(download);

        return fragment;
    };
    FileData.prototype.getFileName = function() {
        return this.fd.name;
    };
    FileData.prototype.getFileSize = function() {
        return this.fd.size;
    };
    FileData.prototype.getFileBuffer = function() {
        return this.fd.buffer;
    };

})(DAV);

(function(DAV) {

    DAV.DragDrop = DragDrop;

    function DragDrop(callback) {
        this.callback = callback;

        this.setUp();
    }

    DragDrop.prototype.setUp = function() {
        var layer = DAV.Layer.get();

        doc.addEventListener('dragenter', this, false);
        doc.addEventListener('dragover',  this, false);
        doc.addEventListener('dragleave', this, false);

        // Drop element event handle
        layer.addEventListener('dragenter', this.cancelEvent, false);
        layer.addEventListener('dragover',  this.cancelEvent, false);
        layer.addEventListener('dragleave', this,        false);
        layer.addEventListener('drop',      this,        false);
    };

    DragDrop.prototype.cancelEvent = function(evt) {
        evt.preventDefault();
        evt.stopPropagation();
    };

    DragDrop.prototype.handleEvent = function(evt) {
        switch ( evt.type ) {
            case 'dragenter':
            case 'dragover':
                  this.dragInit(evt);
                break;
            case 'dragleave':
                this.dragEnd(evt);
                break;
            case 'drop':
                this.dropFile(evt);
                break;
            default :
                break;
        }
    };

    DragDrop.prototype.dragInit = function(evt) {
        DAV.Layer.show(false, 'Dropでアップロードできます');
    };

    DragDrop.prototype.dragEnd = function(evt) {
        evt.preventDefault();
        if ( evt.pageX < 1 || evt.pageY < 1 ) {
            DAV.Layer.hide();
        }
    };

    DragDrop.prototype.dropFile = function(evt) {
        this.cancelEvent(evt);
        DAV.Layer.hide();

        console.log(this.callback);
        this.callback(evt.dataTransfer.files);
    };
})(DAV);

DAV.buckets       = {};
DAV.currentBucket = null;

DAV.init = function() {
    var selected = localStorage.getItem('selectedBucket');

    DAV.Layer.show(true, 'Bucket情報を取得中...');
    DAV.Bucket.getBucketList()
    .done(function(buckets) {
        var menu = doc.querySelector('.buckets > ul');

        if ( buckets.length === 0 ) {
            return alert('Buckets not found.\nPlease create bucket on AWS management console.');
        }

        buckets.forEach(function(bucket, index) {
            var item     = doc.createElement('li'),
                a        = doc.createElement('a'),
                name     = bucket.getName(),
                isActive = false;

            if ( selected === name ) {
                item.setAttribute('class', 'active');
                DAV.SideMenu.setActiveElement(item);
                isActive           = true;
                DAV.currentBucket = name;
            }
            
            a.appendChild(doc.createTextNode(name));
            a.setAttribute('href', name);
            item.appendChild(a);
            item.setAttribute('data-bucketname', name);
            menu.appendChild(item, isActive);
            DAV.buckets[name] = bucket;
        });

        if ( ! DAV.currentBucket ) {
            DAV.currentBucket = buckets[0].getName();
            DAV.SideMenu.setActiveElement(menu.firstElementChild);
        }
        
        DAV.loadObjects(DAV.currentBucket, '/');
    });

    new DAV.DragDrop(DAV.Bucket.uploadObject);
};

DAV.loadObjects = function(bucketName, dir) {
    var bucket = DAV.buckets[bucketName],
        cache;

    console.log(arguments);
    if ( ! bucket ) {
        return alert('Error: bucket "' + bucketName + '" not found');
    }

    DAV.Layer.show(true, bucket.getName() + 'のファイル一覧を取得中...');

    cache = DAV.FileList.getByCache(bucketName, dir);
    if ( cache !== null ) {
        console.log('Loaded from cache' + bucketName + '/dir');
        DAV.FileList.reload(cache, dir);
        DAV.Layer.hide();
    } else {
        bucket.getItems(dir)
        .done(function(items) {
            DAV.FileList.reload(items.getItems(), dir);
            DAV.Layer.hide();
        });
    }
};

var config = DAV.Setting.getConfigObject();

if ( config === null ) {
    DAV.Setting.show(Main.init, true);
} else {
    DAV.Server.config.update(config);
    DAV.init();
}
